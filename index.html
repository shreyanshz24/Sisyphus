<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Josephus Problem Game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f8f9fa;
      color: #333;
    }

    h1 {
      margin-top: 20px;
    }

    #controls {
      margin: 20px;
    }

    canvas {
      border: 1px solid #ccc;
      margin-top: 20px;
      background: white;
    }

    #result {
      margin-top: 20px;
      font-weight: bold;
      font-size: 18px;
    }

    #nextStepBtn {
      display: none;
      margin-left: 10px;
    }

    #puzzleControls {
      display: none;
      margin-top: 10px;
    }

    #leaderboard {
      margin-top: 12px;
      font-size: 14px;
    }

    #clearScores {
      margin-left: 8px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>Josephus Problem Game üéÆ</h1>

  <div id="controls">
    <label>Number of players (n):
      <input type="number" id="numPlayers" value="10" min="2">
    </label>

    <label>Step size (k):
      <input type="number" id="stepSize" value="3" min="2">
    </label>

    <label>Your seat:
      <input type="number" id="playerSeat" value="1" min="1">
    </label>

    <label>Mode:
      <select id="modeSelect">
        <option value="classic">Classic (auto)</option>
        <option value="step">Step-by-step</option>
        <option value="puzzle">Puzzle (guess safe spot)</option>
      </select>
    </label>

    <button id="startBtn">Start Game</button>
    <button id="nextStepBtn">Next Step</button>
  </div>

  <div id="puzzleControls">
    <label>Guess safe spot:
      <input type="number" id="guessInput" min="1">
    </label>
    <button id="submitGuessBtn">Submit Guess</button>
  </div>

  <canvas id="gameCanvas" width="600" height="600"></canvas>

  <div id="result"></div>

  <div id="leaderboard">
    <div><b>Puzzle Leaderboard (local)</b>
      <button id="clearScores">Clear</button>
    </div>
    <ul id="scoreList"></ul>
  </div>

  <script>
    // KEEPING ORIGINAL VARIABLE NAMES & STRUCTURE AS CLOSE AS POSSIBLE

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const startBtn = document.getElementById("startBtn");
    const resultDiv = document.getElementById("result");
    const nextStepBtn = document.getElementById("nextStepBtn");
    const modeSelect = document.getElementById("modeSelect");
    const puzzleControls = document.getElementById("puzzleControls");
    const guessInput = document.getElementById("guessInput");
    const submitGuessBtn = document.getElementById("submitGuessBtn");
    const scoreList = document.getElementById("scoreList");
    const clearScoresBtn = document.getElementById("clearScores");

    // game state arrays
    let players = [];
    let eliminated = [];
    let n, k, playerSeat;

    // internal control variables (kept explicit for step control)
    let currentIndex = 0;
    let currentStep = 0;
    let gameInterval = null;

    // puzzle-mode guess
    let playerGuess = null;

    // leaderboard stored in localStorage for puzzle mode
    let puzzleScores = JSON.parse(localStorage.getItem("josephus_puzzle_scores") || "[]");
    updateLeaderboardUI();

    // ---------- Event bindings (explicit, not compacted) ----------
    startBtn.addEventListener("click", () => {
      n = parseInt(document.getElementById("numPlayers").value, 10);
      k = parseInt(document.getElementById("stepSize").value, 10);
      playerSeat = parseInt(document.getElementById("playerSeat").value, 10);

      if (isNaN(n) || n < 2) {
        alert("Number of players (n) must be at least 2.");
        return;
      }
      if (isNaN(k) || k < 1) {
        alert("Step size (k) must be at least 1.");
        return;
      }
      if (playerSeat < 1 || playerSeat > n) {
        alert("Your seat must be between 1 and " + n);
        return;
      }

      const mode = modeSelect.value;
      playerGuess = null; // reset previous guess

      // mode UI toggles
      if (mode === "step") {
        nextStepBtn.style.display = "inline-block";
        puzzleControls.style.display = "none";
      } else if (mode === "puzzle") {
        nextStepBtn.style.display = "none";
        puzzleControls.style.display = "block";
      } else {
        nextStepBtn.style.display = "none";
        puzzleControls.style.display = "none";
      }

      // initialize and run according to mode
      initGame();

      if (mode === "classic") {
        // auto-run
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(() => {
          eliminationStep();
        }, 700);
      } else if (mode === "step") {
        // step-by-step: user will click Next Step
        if (gameInterval) clearInterval(gameInterval);
      } else if (mode === "puzzle") {
        // puzzle: wait for guess submit, then auto-run
        if (gameInterval) clearInterval(gameInterval);
      }
    });

    nextStepBtn.addEventListener("click", () => {
      eliminationStep();
    });

    submitGuessBtn.addEventListener("click", () => {
      // validate guess
      const g = parseInt(guessInput.value, 10);
      if (isNaN(g) || g < 1 || g > n) {
        alert("Enter a valid guess between 1 and " + n);
        return;
      }
      playerGuess = g;

      // start auto-run for puzzle after guess
      if (gameInterval) clearInterval(gameInterval);
      gameInterval = setInterval(() => {
        eliminationStep();
      }, 700);

      resultDiv.textContent = "Guess submitted ‚Äî running simulation...";
    });

    clearScoresBtn.addEventListener("click", () => {
      if (confirm("Clear puzzle leaderboard?")) {
        puzzleScores = [];
        localStorage.setItem("josephus_puzzle_scores", JSON.stringify(puzzleScores));
        updateLeaderboardUI();
      }
    });

    // ---------- Core functions (preserved style/structure) ----------

    function initGame() {
      players = [];
      eliminated = [];
      resultDiv.textContent = "";

      for (let i = 1; i <= n; i++) {
        players.push(i);
      }

      // reset step/index tracking for new game
      currentIndex = 0;
      currentStep = 0;

      drawCircle(players, eliminated);
    }

    function eliminationStep() {
      // single-step elimination logic; can be called by interval or Next Step
      if (players.length === 1) {
        if (gameInterval) {
          clearInterval(gameInterval);
          gameInterval = null;
        }

        let winner = players[0];
        let safeSpot = josephus(n, k);
        let survived = (playerSeat === winner);

        // if puzzle mode compare guess and store
        if (modeSelect.value === "puzzle") {
          let resultText = "";
          if (playerGuess === null) {
            resultText = "No guess made.";
            resultDiv.innerHTML = `You didn't guess. Safe position was <b>${safeSpot}</b>.`;
          } else if (playerGuess === safeSpot) {
            resultText = "Correct";
            resultDiv.innerHTML = `üéâ Correct! Safe position is <b>${safeSpot}</b>. You ${survived ? "survived üéâ" : "were eliminated üíÄ"}`;
          } else {
            resultText = "Wrong";
            resultDiv.innerHTML = `‚ùå Wrong. You guessed <b>${playerGuess}</b>. Safe position is <b>${safeSpot}</b>. You ${survived ? "survived üéâ" : "were eliminated üíÄ"}`;
          }

          // store puzzle result (local leaderboard)
          puzzleScores.push({ guess: playerGuess === null ? "none" : playerGuess, safeSpot: safeSpot, result: resultText });
          localStorage.setItem("josephus_puzzle_scores", JSON.stringify(puzzleScores));
          updateLeaderboardUI();

        } else if (modeSelect.value === "classic" || modeSelect.value === "step") {
          // classic/step summary
          resultDiv.innerHTML = `Winner is seat <b>${winner}</b><br>Safe position (mathematical solution): <b>${safeSpot}</b><br>You ${survived ? "survived üéâ" : "were eliminated üíÄ"}`;
        } else {
          // fallback
          resultDiv.innerHTML = `Winner is seat <b>${winner}</b><br>Safe position: <b>${safeSpot}</b>`;
        }
        return;
      }

      // normal elimination progression
      currentStep++;
      if (currentStep === k) {
        // eliminate currentIndex
        eliminated.push(players[currentIndex]);
        players.splice(currentIndex, 1);
        currentStep = 0;
      } else {
        currentIndex++;
      }

      if (currentIndex >= players.length) currentIndex = 0;

      drawCircle(players, eliminated);
    }

    function drawCircle(players, eliminated) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const radius = 200;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;

      let total = players.length + eliminated.length;

      for (let i = 0; i < total; i++) {
        const angle = (2 * Math.PI * i) / total - Math.PI / 2;
        const x = cx + radius * Math.cos(angle);
        const y = cy + radius * Math.sin(angle);

        ctx.beginPath();
        ctx.arc(x, y, 20, 0, 2 * Math.PI);

        if (eliminated.includes(i + 1)) {
          ctx.fillStyle = "red";
        } else if (players.includes(i + 1)) {
          ctx.fillStyle = (i + 1 === playerSeat) ? "lightgreen" : "lightblue";
        } else {
          ctx.fillStyle = "gray";
        }

        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "black";
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(i + 1, x, y);
      }
    }

    // Josephus problem solution (iterative formula; same as your original)
    function josephus(n, k) {
      let res = 0;
      for (let i = 1; i <= n; i++) {
        res = (res + k) % i;
      }
      return res + 1;
    }

    // ---------- Leaderboard UI helper ----------
    function updateLeaderboardUI() {
      scoreList.innerHTML = "";
      for (let i = 0; i < puzzleScores.length; i++) {
        const e = puzzleScores[i];
        const li = document.createElement("li");
        li.textContent = `Game ${i + 1}: ${e.result} (Safe: ${e.safeSpot}, Guess: ${e.guess})`;
        scoreList.appendChild(li);
      }
    }

    // Keep draw at least once initially
    drawCircle(players, eliminated);

  </script>
</body>
</html>